<!DOCTYPE html>

<html>

<head>
<title>Three.js Funsies</title>
<script src="./three.min.js"></script>
<script src="./OculusBridge.min.js"></script>
<style>
	body{
		margin: 0;
		overflow: hidden;
	}
	/*Following code adapted from http://instrument.github.io/oculus-bridge/examples/connect.html */
	#stats{
		position:absolute;
		top:20px;
		left:20px;
		color: #000000;
		background-color: #FFFFFF; 
	}

	#stats div {
		margin-bottom:5px;
	}

	#stats div label {
		display:inline-block;
		width:200px;
	}
</style>
</head>
<body>

	<div id="stats"></div>
    <div id="viewport"></div>

<script type="text/javascript">
	var t3 = THREE;

	var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
    camera.position.set(30, -30, 30);
    camera.up = new THREE.Vector3(0,0,1);
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    var scene = new THREE.Scene();
    renderer.setClearColor(0xffffff, 1);

    // renderer = new THREE.OculusRiftEffect(renderer,	{worldScale: 100}); //		_self.resizeCanvas();
	
	var light = new THREE.PointLight( 0xffffff, 1, 400 );
	light.position.set( 10, 10, 80 );
	scene.add( light );

	make_solenoid(scene, 5, new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1), 10);

	//****************************************************//
	// code from http://instrument.github.io/oculus-bridge/examples/connect.html
	// using pieces of https://github.com/Instrument/oculus-bridge
	var accelerationIndicator;
	function createAccelerometerUI(){

		// build a grid for scale
		var material = new THREE.LineBasicMaterial({ color: 0x515151 });

		var geometry = new THREE.Geometry();
		for(var i = -10; i < 11; i+=2){
			geometry.vertices.push( new THREE.Vector3( i*10, 0, -100 ) );
			geometry.vertices.push( new THREE.Vector3( i*10, 30, -100 ) );
		}

		geometry.vertices.push( new THREE.Vector3( -100, 10, -100 ) );
		geometry.vertices.push( new THREE.Vector3( 100, 10, -100 ) );

		geometry.vertices.push( new THREE.Vector3( -100, 20, -100 ) );
		geometry.vertices.push( new THREE.Vector3( 100, 20, -100 ) );

		var line = new THREE.Line( geometry, material, THREE.LinePieces );
		scene.add( line );

		// add indicators for accelerometer values
		var accelerationValues = [
			new THREE.Mesh( new THREE.CubeGeometry(1,10,1), new THREE.MeshLambertMaterial({color:0xff0000, emissive:0x600000}) ),
			new THREE.Mesh( new THREE.CubeGeometry(1,10,1), new THREE.MeshLambertMaterial({color:0x00ff00, emissive:0x006000}) ),
			new THREE.Mesh( new THREE.CubeGeometry(1,10,1), new THREE.MeshLambertMaterial({color:0x0000ff, emissive:0x000060}) )
		];

		accelerationIndicator = new THREE.Object3D();
		accelerationIndicator.position.set(0,5,-100);
		for(var i = 0; i < accelerationValues.length; i++){
			accelerationValues[i].position.set(0, i*10, 0);
			accelerationIndicator.add(accelerationValues[i]);
		}
		scene.add(accelerationIndicator);
	}

	function bridgeConfigUpdated(config){
		var stats = document.getElementById("stats");

		stats.innerHTML = "Display Configuration<hr>";

		// Show all the parameters in the config object.
		for(var itm in config){
			var row = document.createElement("div");
			var label = document.createElement("label");
			var value = document.createElement("span");

			label.innerHTML = itm;
			value.innerHTML = config[itm];

			row.appendChild(label);
			row.appendChild(value);
			stats.appendChild(row);
		}
	}


	function bridgeAccelerationUpdated(accel) {
		// scale values so 1g = 20 world units
		accelerationIndicator.children[0].position.x = (accel.x * 1.02040816326531) * 2;
		accelerationIndicator.children[1].position.x = (accel.y * 1.02040816326531) * 2;
		accelerationIndicator.children[2].position.x = (accel.z * 1.02040816326531) * 2;
	}

	function bridgeOrientationUpdated(quat) {
		referenceCube.quaternion.set(quat.x, quat.y, quat.z, quat.w);
	}

	function bridgeConnected(){
		var stats = document.getElementById("stats");
		stats.innerHTML = "Bridge Connected!";
		document.getElementById("logo").className = "";
	}

	function bridgeDisconnected(){
		var stats = document.getElementById("stats");
		stats.innerHTML = "Bridge Disconnected.";
		document.getElementById("logo").className = "offline"
	}

	oculusBridge = new OculusBridge({
		onOrientationUpdate  : bridgeOrientationUpdated,
		onAccelerationUpdate : bridgeAccelerationUpdated,
		onConfigUpdate       : bridgeConfigUpdated,
		onConnect            : bridgeConnected,
		onDisconnect         : bridgeDisconnected
	});
	oculusBridge.connect();
	//****************************************************//

	function make_solenoid(s, r, origin, dir, length) { 
		this.radius = r; 
		this.origin = origin; 
		this.dir = dir; 
		this.length = length;
		this.current = 1;

		var alpha = 0.05;
		var beta = 0.09;

		var normal = dir.clone();
		var temp = new THREE.Vector3(0, 0, 0);
		temp.crossVectors(normal, new THREE.Vector3(1,0,0));
		if (temp == new THREE.Vector3(0,0,0)) {
		    temp.crossVectors(normal, new THREE.Vector3(0,1,0));
		}
		temp.normalize();
		var perp1 = temp.clone();
		var perp2 = new THREE.Vector3(0, 0, 0);
		perp2.crossVectors(normal, perp1);
		perp2.normalize();
		console.log(normal); console.log(perp1); console.log(perp2);
		
		this.perp1 = perp1;
		this.perp2 = perp2;

		var pi=3.14;
		 
		var circle_vertices = 100; //choose what you want
		var circle_vertex = new Array(circle_vertices);

		//
		var g = new THREE.Geometry();
    	var material = new THREE.LineBasicMaterial({
	        color: 0x0000ff
	    });
	    var line = new THREE.Line(g, material);
	    //

	    var points = new Array();
	    for (ra = 1; ra < 3 * this.radius; ra += 3) {
	    	for (theta = 0; theta < 2 * pi; theta += 2 / ra) { // pi / 3) {
	    		for (z = 0; z < length * 1.5; z += 2) {
	    			var point = new THREE.Vector3(ra * Math.cos(theta), ra * Math.sin(theta), z)
	    			points.push(point);
	    			// make_arrow(s, point, new THREE.Vector3(0, 0, 1), 1, 0xff0000)
	    		}
	    	}
	    }

	    var field = new Array(points.length) // parallel array
	    for (i = 0; i < field.length; i++) {
	    	field[i] = new THREE.Vector3(0, 0, 0);
	    }

	    make_arrow(s, origin, dir, length);

		for (step = 0; step < circle_vertices; ++step)
		{
		    var angle = step * pi * 2 * alpha;
		    v1 = perp1.clone()
		    v1.multiplyScalar(this.radius * Math.sin(angle));
		    v2 = perp2.clone()
		    v2.multiplyScalar(this.radius * Math.cos(angle));
		    v3 = dir.clone();
		    v3.multiplyScalar(step * beta);
		    v1.add(v2);  v1.add(v3); // v3 is the difference between a circle and a solenoid
		    g.vertices.push(v1);
		    // so v1 is the position of this vector
		    // now I need the electric field caused by this point
			var d_length = 1;
			var k = 1;
			var mu_naught = 1;
			for (i = 0; i < points.length; i++) {
				var r = new THREE.Vector3();
				// console.log(r);
				// console.log(points[i], v1);
				r.subVectors(points[i], v1);
				// console.log(r);
				var mag_r = r.length();
				// console.log(mag_r);
				// var e = k * this.charge_density * d_length / mag_r / mag_r / mag_r;
				var rad = v1.clone();
				rad.sub(v3);
				var cur = new THREE.Vector3();
				cur.crossVectors(v3, rad);
				var b = new THREE.Vector3();
				b.crossVectors(cur, r);
				b.normalize();
				b.multiplyScalar(mu_naught * this.current / (2 * pi * mag_r));
				// console.log(e);
				field[i].add(b);
				//
				// the direction of current is perindicular to v1 - v3 and v3 so (v3 x (v1 - v3))
 				// and then the direction of the field cause by that current is [direction of current] x [path from current to point]
				// 
				//
			}
		}
		// https://www.opengl.org/discussion_boards/showthread.php/124624-equation-of-a-circle-in-3D
		console.log(field.length)
		console.log(points.length)
		console.log(s)
		for (i = 0; i < field.length; i++) {
			var e = field[i].length();
			field[i].normalize();
			// console.log(e, field[i])
			// make_arrow(s, points[i], field[i], e, 0x00cc00);
		}
		s.add(line);
	}

	function make_arrow(s, origin, dir, length, hex) {
		// var dir = new THREE.Vector3( 1, 0, 0 );
		// var origin = new THREE.Vector3( 0, 0, 0 );
		// var length = 10;
		// var hex = 0x000000;

		var arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex, length / 3, length / 3);
		s.add( arrowHelper );
	}


    function make_axes(s, r, x0, y0, z0) {
    	var g = new THREE.Geometry();

    	var material = new THREE.LineBasicMaterial({
	        color: 0x0000ff
	    });

	    var line = new THREE.Line(g, material);

    	add_spoke(g, x0 + r, y0, z0, x0, y0, z0);
	    add_spoke(g, x0 - r, y0, z0, x0, y0, z0);
	    add_spoke(g, x0, y0 + r, z0, x0, y0, z0);
	    add_spoke(g, x0, y0 - r, z0, x0, y0, z0);
	    add_spoke(g, x0, y0, z0 + r, x0, y0, z0);
	    add_spoke(g, x0, y0, z0 - r, x0, y0, z0);

	    s.add(line);
    }

    function add_spoke(geometry, x, y, z, x0, y0, z0) {
		geometry.vertices.push(new THREE.Vector3(x, y, z));
		geometry.vertices.push(new THREE.Vector3(x0, y0, z0));
	}

	var theta = 0;
	var render = function () {
		requestAnimationFrame( render );

		// theta += 0.02;
		camera.position.y = 30 * Math.cos(theta);
		camera.position.x = 30 * Math.sin(theta);

		camera.lookAt(new THREE.Vector3(0, 0, 0));

		// console.log(camera.rotation)
		// camera.rotation.x = theta;
		// camera.rotation.y = 0;
		// camera.rotation.z = theta + 0.5;
		// console.log(camera.rotation)

		renderer.render(scene, camera);
	};

	render();

</script>
</body>
</html>