<!DOCTYPE html>

<html>

<head>
<title>Point Charges</title>
	<script src="three.min.js"></script>
	<script src="three/examples/js/effects/VREffect.js"></script>
	<script src="three/examples/js/controls/VRControls.js"></script>
	<script src="three/examples/js/libs/stats.min.js"></script>
<style>
body{
	/* set margin to 0 and overflow to hidden, 
	to use the complete page */
	margin: 0;
	overflow: hidden;
}
.menu {
	position: fixed;
	bottom: 20px;
	right: 20px;
}

.button {
	display: inline-block;
	padding: 8px;
	color: #FFF;
	background-color: #555;
}

.button.enabled {
	background-color: rgb(18, 36, 70);
}

.button:hover {
	cursor: pointer;
	background-color: rgb(18, 36, 70);
}

.button.error {
	pointer-events: none;
	background-color: red;
}
</style>
</head>
<body>

	<div class="menu">
		<div class="button full-screen">Start VR Mode</div>
	</div>


<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">
	var t3, camera, scene, renderer;
	var raycaster, container, stats, vrEffect, vrControls;
	var crosshair, INTERSECTED;
	var theta = 0;
	var camera_radius = 30;
	init();
	animate();

	function init() {
		container = document.createElement( 'div' );
		document.body.appendChild( container );

		var info = document.createElement( 'div' );
		info.style.position = 'absolute';
		info.style.top = '10px';
		info.style.width = '100%';
		info.style.textAlign = 'center';
		info.innerHTML = 'electric point charges'; // '<a href="http://threejs.org" target="_blank">three.js</a> - electric point charges';
		container.appendChild( info );

		var t3 = THREE;

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
	    renderer.setSize(window.innerWidth, window.innerHeight);
	    renderer.setClearColor(0xffffff, 1);
	    container.appendChild(renderer.domElement);

	    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
	    camera.position.set(camera_radius, 0, camera_radius);
	    camera.up = new THREE.Vector3(0,0,1);
	    camera.lookAt(new THREE.Vector3(0, 0, 0));

	    scene = new THREE.Scene();
		
		var light = new THREE.PointLight( 0xffffff, 1, 400 );
		light.position.set( 10, 10, 80 );
		scene.add( light );

		// crosshair = new THREE.Mesh(
		// 	new THREE.RingGeometry( 0.5, 1, 32 ),
		// 	new THREE.MeshBasicMaterial( {
		// 		color: 0x00bb00,
		// 		transparent: true,
		// 		opacity: 0.5
		// 	} )
		// );
		crosshair = make_sphere(scene, 0.3, 0, 0, 0, 0x00bb00);
		// scene.add( crosshair );

		raycaster = new THREE.Raycaster();

		charge_list = [];
		charge_list.push(new PointCharge(scene, -10, -10, 0, 1, -10));
		charge_list.push(new PointCharge(scene, 10, 10, 0, 1, 10));
		charge_list.push(new PointCharge(scene, -10, -10, 20, 1, 10));
		charge_list.push(new PointCharge(scene, -10, -10, -20, 1, 10));
		charge_list.push(new PointCharge(scene, -25, -25, 3, 1, -5));

		make_electric_field(scene, charge_list);

		var fullScreenButton = document.querySelector( '.full-screen' );

		if ( navigator.getVRDevices === undefined ) {
			fullScreenButton.innerHTML = 'Your browser doesn\'t support WebVR';
			fullScreenButton.classList.add('error');
		}

		vrControls = new THREE.VRControls( camera );
		vrEffect = new THREE.VREffect( renderer, function ( error ) {
			fullScreenButton.innerHTML = error;
			fullScreenButton.classList.add('error');
		} );

		fullScreenButton.onclick = function() {
			vrEffect.setFullScreen( true );
		};

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild( stats.domElement );

		window.addEventListener( 'resize', onWindowResize, false );
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		vrEffect.setSize( window.innerWidth, window.innerHeight );
	}

	function make_electric_field(s, charges) {
		var k = 1;
		for (x = -30; x <= 30; x += 5) {
			for (y = -30; y <= 30; y += 5) {
				for (z = -15; z <= 15; z += 5) {
					var pos = new THREE.Vector3(x, y, z);
					var net_field = new THREE.Vector3(0, 0, 0);
					// console.log(net_field)
					for (i = 0; i < charges.length; i++) {
						var r = new THREE.Vector3();
						r.subVectors(pos, charges[i].vec);
						var mag_r = r.length();
						// console.log(mag_r)
						var e = k * charges[i].charge / mag_r / mag_r / mag_r;
						r.multiplyScalar(e);
						net_field.add(r);
						// console.log(net_field)
					}
					var e = net_field.length();
					net_field.normalize();
					// console.log("magnitude: " + e);
					// console.log("direction: " + net_field);
					make_arrow(s, pos, net_field, e);
				}
			}
		}
	}

	function make_arrow(s, origin, dir, magnitude) {
		// center of arrow on origin
		var length = magnitude * 17;
		var hex = 0x000000;
		var arrow_length = 2;

		var halfway_back = new THREE.Vector3();
		halfway_back.copy(dir);
		halfway_back.multiplyScalar(arrow_length / 2);
		halfway_back.negate();

		 var new_orig = new THREE.Vector3();
		 new_orig.subVectors(origin, halfway_back);

		var arrowHelper = new THREE.ArrowHelper( dir, new_orig, arrow_length, hex, arrow_length / 2, magnitude * 5);
		// arrowHelper.cone
		// arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex, length / 3, length / 3);

		s.add( arrowHelper );
		
	}

	function PointCharge(s, x0, y0, z0, r, q) {
		this.scene = s;
		this.x0 = x0;
		this.y0 = y0;
		this.z0 = z0;
		this.vec = new THREE.Vector3(x0, y0, z0);
		this.radius = r;
		this.charge = q;
		// make_axes(scene, r * 2, x0, y0, z0);
		this.hex = (q < 0) ? 0x0000ff : 0xff0000;
		make_sphere(scene, r, x0, y0, z0, this.hex);
	}

	function make_curve() {
		var curve = new THREE.QuadraticBezierCurve3(
		new THREE.Vector3(-10, -10, 0),
		new THREE.Vector3(0, 0, 50),
		new THREE.Vector3(10, 10, 0)
		);

		var path = new THREE.Path( curve.getPoints( 50 ) );

		var geometry = path.createPointsGeometry( 50 );
		geometry.vertices = curve.getPoints(50);
		var material = new THREE.LineBasicMaterial( { color : 0xff0000 } );

		//Create the final Object3d to add to the scene
		// var curveObject = new THREE.Line( geometry, material );
		return new THREE.Line(geometry, material);
	}

	function make_sphere(s, r, x0, y0, z0, hex) {
		var s_geometry = new THREE.SphereGeometry( r, 32, 32 );
		var s_material = new THREE.MeshLambertMaterial( {color: hex} );
		var sphere = new THREE.Mesh( s_geometry, s_material );
		sphere.position.set(x0, y0, z0);
		s.add( sphere );
	}
    // renderer.render(scene, camera);
    function make_axes(s, r, x0, y0, z0) {
    	var g = new THREE.Geometry();

    	var material = new THREE.LineBasicMaterial({
	        color: 0x0000ff
	    });

	    var line = new THREE.Line(g, material);

    	add_spoke(g, x0 + r, y0, z0, x0, y0, z0);
	    add_spoke(g, x0 - r, y0, z0, x0, y0, z0);
	    add_spoke(g, x0, y0 + r, z0, x0, y0, z0);
	    add_spoke(g, x0, y0 - r, z0, x0, y0, z0);
	    add_spoke(g, x0, y0, z0 + r, x0, y0, z0);
	    add_spoke(g, x0, y0, z0 - r, x0, y0, z0);

	    s.add(line);
    }

    function add_spoke(geometry, x, y, z, x0, y0, z0) {
		geometry.vertices.push(new THREE.Vector3(x, y, z));
		geometry.vertices.push(new THREE.Vector3(x0, y0, z0));
	}

	window.addEventListener('keydown', key_listener, true);
	function key_listener(event) {
		console.log(event.keyCode);

		switch(event.keyCode) {
			case 87: // w
				zoom_in();
				break;
			case 65: // a
				look_left();
				break;
			case 83: // s
				zoom_out();
				break;
			case 68: // d
				look_right();
				break;
			case 37: // left arrow
			case 38: // up arrow
			case 39: // right arrow
			case 40: // down arrow
		}
	}
	//----- Camera Functions -----//
	function look_left() {
		console.log("L");
	}
	function look_right() {
		console.log("R");
	}
	function zoom_in() {
		console.log("IN");
		if (camera_radius > 5 && camera.position.z > 5) {
			camera_radius -= 5;
			camera.position.z -= 5;
		}
	}
	function zoom_out() {
		console.log("OUT");
		camera_radius += 5;
		camera.position.z += 5;
	}
	function pick_charge() {
		//
	}

	function animate() {
		requestAnimationFrame( animate );

		render();
	}

	function render() {
		theta += 0.01;
		camera.position.y = camera_radius * Math.cos(theta);
		camera.position.x = camera_radius * Math.sin(theta);
		camera.lookAt(new THREE.Vector3(0, 0, 0));


		// renderer.render(scene, camera);


		// raycaster.setFromCamera( { x: 0, y: 0 }, camera );
		// var intersects = raycaster.intersectObjects( cubes );
		// if ( intersects.length > 0 ) {
		// 	if ( INTERSECTED != intersects[ 0 ].object ) {
		// 		if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
		// 		INTERSECTED = intersects[ 0 ].object;
		// 		INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
		// 		INTERSECTED.material.emissive.setHex( 0xff0000 );
		// 	}
		// } else {
		// 	if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
		// 	INTERSECTED = null;
		// }
		// vrControls.update();
		// crosshair.quaternion.copy( camera.quaternion );
		// crosshair.position.set( 0, 0, 0 );
		// if ( INTERSECTED ) {
		// 	crosshair.translateZ(
		// 		-scene.position.distanceTo( INTERSECTED.position ) +
		// 		INTERSECTED.geometry.boundingSphere.radius + 5
		// 	);
		// }
		// else {
		// 	crosshair.translateZ(-40);
		// }
		vrEffect.render( scene, camera );
	};

</script>
</body>
</html>