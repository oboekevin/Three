<!DOCTYPE html>

<html>

<head>
<title>Point Charges</title>
	<script src="three.min.js"></script>
	<script src="three/examples/js/effects/VREffect.js"></script>
	<script src="three/examples/js/controls/VRControls.js"></script>
	<script src="three/examples/js/libs/stats.min.js"></script>
	<script src="three/examples/fonts/helvetiker_regular.typeface"></script>
<style>
body{
	/* set margin to 0 and overflow to hidden, 
	to use the complete page */
	margin: 0;
	overflow: hidden;
}
.menu {
	position: fixed;
	bottom: 20px;
	right: 20px;
}

.button {
	display: inline-block;
	padding: 8px;
	color: #FFF;
	background-color: #555;
}

.button.enabled {
	background-color: rgb(18, 36, 70);
}

.button:hover {
	cursor: pointer;
	background-color: rgb(18, 36, 70);
}

.button.error {
	pointer-events: none;
	background-color: red;
}
</style>
</head>
<body>

	<div class="menu">
		<div class="button full-screen">Start VR Mode</div>
	</div>


<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">
	var t3, camera, scene, renderer;
	var raycaster, container, stats, vrEffect, vrControls;
	var crosshair, INTERSECTED;
	var charge_list, electric_field;
	var theta = 0;
	var camera_radius = 30;
	var K = 1;
	var selected_id;
	var P = 5;
	init();
	animate();

	function init() {
		container = document.createElement( 'div' );
		document.body.appendChild( container );

		var info = document.createElement( 'div' );
		info.style.position = 'absolute';
		info.style.top = '10px';
		info.style.width = '100%';
		info.style.textAlign = 'center';
		info.innerHTML = 'electric point charges'; // '<a href="http://threejs.org" target="_blank">three.js</a> - electric point charges';
		container.appendChild( info );

		var t3 = THREE;

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
	    renderer.setSize(window.innerWidth, window.innerHeight);
	    renderer.setClearColor(0xffffff, 1);
	    container.appendChild(renderer.domElement);

	    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
	    camera.position.set(camera_radius, 0, camera_radius);
	    camera.up = new THREE.Vector3(0,0,1);
	    camera.lookAt(new THREE.Vector3(0, 0, 0));

	    scene = new THREE.Scene();
		
		var light = new THREE.PointLight( 0xffffff, 1, 400 );
		light.position.set( 10, 10, 80 );
		scene.add( light );

		// crosshair = new THREE.Mesh(
		// 	new THREE.RingGeometry( 0.5, 1, 32 ),
		// 	new THREE.MeshBasicMaterial( {
		// 		color: 0x00bb00,
		// 		transparent: true,
		// 		opacity: 0.5
		// 	} )
		// );
		// crosshair = make_sphere(scene, 0.3, 0, 0, 0, 0x00bb00);
		make_axes(scene, 30, 0, 0, 0);
		spx = makeTextSprite("X");
		spx.position = new THREE.Vector3(30, 0, 0);
		scene.add(spx);
		// scene.add( crosshair );

		raycaster = new THREE.Raycaster();

		selected_id = 0;
		charge_list = [];
		charge_list.push(new PointCharge(scene, -10, -10, 0, 1, -10));
		charge_list.push(new PointCharge(scene, 10, 10, 0, 1, 10));
		charge_list.push(new PointCharge(scene, -10, -10, 20, 1, 10));
		charge_list.push(new PointCharge(scene, -10, -10, -20, 1, 10));
		charge_list.push(new PointCharge(scene, -25, -25, 3, 1, -5));

		electric_field = make_electric_field(scene, charge_list);

		var fullScreenButton = document.querySelector( '.full-screen' );

		if ( navigator.getVRDevices === undefined ) {
			fullScreenButton.innerHTML = 'Your browser doesn\'t support WebVR';
			fullScreenButton.classList.add('error');
		}

		vrControls = new THREE.VRControls( camera );
		vrEffect = new THREE.VREffect( renderer, function ( error ) {
			fullScreenButton.innerHTML = error;
			fullScreenButton.classList.add('error');
		} );

		fullScreenButton.onclick = function() {
			vrEffect.setFullScreen( true );
		};

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild( stats.domElement );

		window.addEventListener( 'resize', onWindowResize, false );
	}

	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		vrEffect.setSize( window.innerWidth, window.innerHeight );
	}

	function make_electric_field(s, charges) {
		var field = new Array();
		for (x = -30; x <= 30; x += 5) {
			for (y = -30; y <= 30; y += 5) {
				for (z = -15; z <= 15; z += 5) {
					field.push({pos: new THREE.Vector3(x, y, z), field: new THREE.Vector3(0, 0, 0)});
					// position vector and field strength vector
				}
			}
		}

		charges.forEach(function(charge) {
			charge.contribute_to_electric_field(field);
		});
		field.forEach(function(F) {
			mag = F.field.length();
			dir = F.field.normalize();
			F.arrow = make_arrow(s, F.pos, dir, mag);
		});
		return field;
	}
	function update_field(s, charges, field) {
		field.forEach(function(F) {
			F.field = new THREE.Vector3(0, 0, 0);
			scene.remove(F.arrow);
		});
		charges.forEach(function(charge) {
			charge.contribute_to_electric_field(field);
		});
		field.forEach(function(F) {
			mag = F.field.length();
			dir = F.field.normalize();
			F.arrow = make_arrow(s, F.pos, dir, mag);
		});
	}

	function make_arrow(s, origin, dir, magnitude) {
		// center of arrow on origin
		var length = magnitude * 17;
		var hex = 0x000000;
		var arrow_length = 2;

		var halfway_back = new THREE.Vector3();
		halfway_back.copy(dir);
		halfway_back.multiplyScalar(arrow_length / 2);
		halfway_back.negate();

		 var new_orig = new THREE.Vector3();
		 new_orig.subVectors(origin, halfway_back);

		var arrowHelper = new THREE.ArrowHelper( dir, new_orig, arrow_length, hex, arrow_length / 2, magnitude * 5);
		// arrowHelper.cone
		// arrowHelper = new THREE.ArrowHelper( dir, origin, length, hex, length / 3, length / 3);
		s.add( arrowHelper );
		return arrowHelper;
	}

	function PointCharge(s, x0, y0, z0, r, q) {
		this.scene = s;
		this.vec = new THREE.Vector3(x0, y0, z0);
		this.radius = r;
		this.charge = q;
		// make_axes(scene, r * 2, x0, y0, z0);
		this.hex = (q < 0) ? 0x0000ff : 0xff0000;
		this.sphere = make_sphere(scene, r, x0, y0, z0, this.hex);
		this.contribution = null;
		this.contribute_to_electric_field = function(field) { // where field is a list of position vectors
			if (this.contribution == null) {
				this.contribution = new Array(field.length);
				field.forEach(function(F, index){
					var r = new THREE.Vector3();
					r.subVectors(F.pos, this.vec);
					var mag_r = r.length();
					var e = K * this.charge / mag_r / mag_r / mag_r;
					r.multiplyScalar(e);
					this.contribution[index] = r;
					F.field.add(r);
				}, this);
			} else {
				console.log('hi');
				field.forEach(function(F, index) {
					F.field.add(this.contribution[index]);
				}, this)
			}
		}
		this.move = function(delta) {
			this.sphere.position.add(delta);
			this.vec.add(delta);
			this.contribution = null;
			update_field(scene, charge_list, electric_field);
		}
		this.move_up = function() {
			this.move(new THREE.Vector3(0, 0, P));
		}
		this.move_down = function() {
			this.move(new THREE.Vector3(0, 0, -P));
		}
		this.move_x_forward = function() {
			this.move(new THREE.Vector3(P, 0, 0));
		}
		this.move_y_forward = function() {
			this.move(new THREE.Vector3(0, P, 0));
		}
		this.move_x_backward = function() {
			this.move(new THREE.Vector3(-P, 0 ,0));
		}
		this.move_y_backward = function() {
			this.move(new THREE.Vector3(0, -P, 0));
		}	
	}

	function make_sphere(s, r, x0, y0, z0, hex) {
		var s_geometry = new THREE.SphereGeometry( r, 32, 32 );
		var s_material = new THREE.MeshLambertMaterial( {color: hex} );
		var sphere = new THREE.Mesh( s_geometry, s_material );
		sphere.position.set(x0, y0, z0);
		s.add( sphere );
		return sphere;
	}
    // renderer.render(scene, camera);
    function make_axes(s, r, x0, y0, z0) {
    	var g = new THREE.Geometry();

    	var material = new THREE.LineBasicMaterial({
	        color: 0x0000ff
	    });

	    var line = new THREE.Line(g, material);

    	add_spoke(g, x0 + r, y0, z0, x0, y0, z0);
	    add_spoke(g, x0 - r, y0, z0, x0, y0, z0);
	    add_spoke(g, x0, y0 + r, z0, x0, y0, z0);
	    add_spoke(g, x0, y0 - r, z0, x0, y0, z0);
	    add_spoke(g, x0, y0, z0 + r, x0, y0, z0);
	    add_spoke(g, x0, y0, z0 - r, x0, y0, z0);

	    s.add(line);

	 //    var param = {height: 20,
		// 		size: 70,
		// 		hover: 30,
		// 		curveSegments: 4,

		// 		bevelThickness: 2,
		// 		bevelSize: 1.5,
		// 		bevelSegments: 3,
		// 		bevelEnabled: true,

		// 		font: "optimer", // helvetiker, optimer, gentilis, droid sans, droid serif
		// 		weight: "bold", // normal bold
		// 		style: "normal" // normal italic
		// }

	    // var text = new THREE.Mesh(new THREE.TextGeometry("hi"), 
	    // 	new THREE.MeshLambertMaterial({color: 0x0000ff}));
	    // s.add(text);
    }

    function add_spoke(geometry, x, y, z, x0, y0, z0) {
		geometry.vertices.push(new THREE.Vector3(x, y, z));
		geometry.vertices.push(new THREE.Vector3(x0, y0, z0));
	}

	// makeTextSprite and roundRect from this source:
	// http://stemkoski.github.io/Three.js/Sprite-Text-Labels.html
	function makeTextSprite( message, parameters )
	{
		if ( parameters === undefined ) parameters = {};
		
		var fontface = parameters.hasOwnProperty("fontface") ? 
			parameters["fontface"] : "Arial";
		
		var fontsize = parameters.hasOwnProperty("fontsize") ? 
			parameters["fontsize"] : 18;
		
		var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
			parameters["borderThickness"] : 4;
		
		var borderColor = parameters.hasOwnProperty("borderColor") ?
			parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
		
		var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
			parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

		// var spriteAlignment = THREE.SpriteAlignment.topLeft;
			
		var canvas = document.createElement('canvas');
		var context = canvas.getContext('2d');
		context.font = "Bold " + fontsize + "px " + fontface;
	    
		// get size data (height depends only on font size)
		var metrics = context.measureText( message );
		var textWidth = metrics.width;
		
		// background color
		context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
									  + backgroundColor.b + "," + backgroundColor.a + ")";
		// border color
		context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
									  + borderColor.b + "," + borderColor.a + ")";

		context.lineWidth = borderThickness;
		// roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
		// 1.4 is extra height factor for text below baseline: g,j,p,q.
		
		// text color
		context.fillStyle = "rgba(0, 0, 0, 1.0)";

		context.fillText( message, borderThickness, fontsize + borderThickness);
		
		// canvas contents will be used for a texture
		var texture = new THREE.Texture(canvas) 
		texture.needsUpdate = true;

		var spriteMaterial = new THREE.SpriteMaterial( 
			{ map: texture } );
		var sprite = new THREE.Sprite( spriteMaterial );
		sprite.scale.set(100,50,1.0);
		return sprite;	
	}

	// function for drawing rounded rectangles
	function roundRect(ctx, x, y, w, h, r) 
	{
	    ctx.beginPath();
	    ctx.moveTo(x+r, y);
	    ctx.lineTo(x+w-r, y);
	    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
	    ctx.lineTo(x+w, y+h-r);
	    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
	    ctx.lineTo(x+r, y+h);
	    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
	    ctx.lineTo(x, y+r);
	    ctx.quadraticCurveTo(x, y, x+r, y);
	    ctx.closePath();
	    ctx.fill();
		ctx.stroke();   
	}

	window.addEventListener('keydown', key_listener, true);
	function key_listener(event) {
		console.log(event.keyCode);

		switch(event.keyCode) {
			case 87: // w
				zoom_in();
				break;
			case 65: // a
				look_left();
				break;
			case 83: // s
				zoom_out();
				break;
			case 68: // d
				look_right();
				break;
			case 188: // <
				previous_charge();
				break;
			case 190: // >
				next_charge();
				break;
			case 73: // i
				charge_list[selected_id].move_up();
				break;
			case 75: // k
				charge_list[selected_id].move_down();
				break;
			case 37: // left arrow
				charge_list[selected_id].move_x_forward();
				break;
			case 38: // up arrow
				charge_list[selected_id].move_y_backward();
				break;
			case 39: // right arrow
				charge_list[selected_id].move_x_backward();
				break;
			case 40: // down arrow
				charge_list[selected_id].move_y_forward();
				break;
		}
	}
	//----- Camera Functions -----//
	function look_left() {
		console.log("L");
		theta += 0.2;
	}
	function look_right() {
		console.log("R");
		theta -= 0.2;
	}
	function zoom_in() {
		console.log("IN");
		if (camera_radius > 5 && camera.position.z > 5) {
			camera_radius -= 5;
			camera.position.z -= 5;
		}
	}
	function zoom_out() {
		console.log("OUT");
		camera_radius += 5;
		camera.position.z += 5;
	}
	function next_charge() {
		selected_id = (selected_id + 1) % charge_list.length;
	}
	function previous_charge() {
		selected_id = (selected_id - 1) % charge_list.length;
	}

	function animate() {
		requestAnimationFrame( animate );

		render();
	}

	function render() {
		// theta += 0.01;
		camera.position.y = camera_radius * Math.cos(theta);
		camera.position.x = camera_radius * Math.sin(theta);
		camera.lookAt(new THREE.Vector3(0, 0, 0));
		// charge_list[0].sphere.translateZ(1);
		// electric_field[0].arrow.translateZ(1);

		// renderer.render(scene, camera);

		vrEffect.render( scene, camera );
	};

</script>
</body>
</html>